# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '3.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import configparser
import json
import math
import os
import re
import threading
import traceback

import requests
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import pyqtSlot, QDir, QThread, QObject, pyqtSignal, QRunnable, QThreadPool, QCoreApplication
from PyQt5.QtWidgets import QFileDialog, QListWidgetItem, QApplication, QMessageBox
from bs4 import BeautifulSoup as bs
import time
import gg

gurl = ""
gpath = ""
gchapters = []
titles = []


# class Runnable(QRunnable):
#     def __init__(self, n, url, chapters, path, func, site, pdf):
#         super().__init__()
#         self.n = n
#         self.url = url
#         self.chapters = chapters
#         self.path = path
#         self.site = site
#         self.pdf = pdf
#         self.prog,self.label = func()
#
#     @pyqtSlot()
#     def run(self):
#
#         # app = QCoreApplication.instance()
#         # Your long-running task goes here ...
#         # try calling add download here
#         # gg.download(self.url,self.chapters,self.path,lambda x: self.prog.setValue(x),self.site,self.pdf)
#         try:
#             gg.test(self.prog.setValue)
#         except Exception as e:
#             print(e)
#
#         # self.prog.setValue(100)
#         # progressBar_2.thread().deleteLater()
#         # print(self.prog.setValue)
#         print("*"*50)
#         # self.prog.deleteLater()
#         # app.quit()
#         # self.finished.emit()
class WorkerSignals(QObject):
    '''
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        tuple (exctype, value, traceback.format_exc() )

    result
        object data returned from processing, anything

    progress
        int indicating % progress

    '''
    finished = pyqtSignal()
    error = pyqtSignal(tuple)
    result = pyqtSignal(object)
    progress = pyqtSignal(int)


class Worker(QRunnable):
    '''
    Worker thread

    Inherits from QRunnable to handler worker thread setup, signals and wrap-up.

    :param callback: The function callback to run on this worker thread. Supplied args and
                     kwargs will be passed through to the runner.
    :type callback: function
    :param args: Arguments to pass to the callback function
    :param kwargs: Keywords to pass to the callback function

    '''

    def __init__(self, fn, *args, **kwargs):
        super(Worker, self).__init__()

        # Store constructor arguments (re-used for processing)
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

        # Add the callback to our kwargs
        self.kwargs['progress_callback'] = self.signals.progress

    @pyqtSlot()
    def run(self):
        '''
        Initialise the runner function with passed args, kwargs.
        '''

        # Retrieve args/kwargs here; and fire processing using them
        try:
            # result = self.fn(*self.args, **self.kwargs)
            result = self.fn(*self.args, **self.kwargs)
        except:
            traceback.print_exc()
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
        else:
            self.signals.result.emit(result)  # Return the result of the processing
        finally:
            self.signals.finished.emit()  # Done



class Ui_MainWindow(object):

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1047, 685)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        self.threadCount = QThreadPool.globalInstance().maxThreadCount()
        self.progress_bars = []
        self.threads = []
        self.titles = []
        self.lastprog = 0
        self.threadpool = QThreadPool()



        self.currthread=0
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tabWidget.sizePolicy().hasHeightForWidth())
        self.tabWidget.setSizePolicy(sizePolicy)
        self.tabWidget.setObjectName("tabWidget")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout(self.tab)
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.search = QtWidgets.QLineEdit(self.tab)
        self.search.setObjectName("search")
        self.horizontalLayout_3.addWidget(self.search)
        self.verticalLayout_2.addLayout(self.horizontalLayout_3)
        self.mangalist = QtWidgets.QListWidget(self.tab)
        # self.mangalist.setResizeMode(QtWidgets.QListView.Adjust)
        self.mangalist.setObjectName("mangalist")
        self.verticalLayout_2.addWidget(self.mangalist)
        self.horizontalLayout_4.addLayout(self.verticalLayout_2)
        spacerItem = QtWidgets.QSpacerItem(20, 8, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Maximum)
        self.horizontalLayout_4.addItem(spacerItem)
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pathedit = QtWidgets.QLineEdit(self.tab)
        self.pathedit.setObjectName("pathedit")
        self.horizontalLayout.addWidget(self.pathedit)
        self.pathbtn = QtWidgets.QPushButton(self.tab)
        self.pathbtn.setObjectName("pathbtn")
        self.horizontalLayout.addWidget(self.pathbtn)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.urledit = QtWidgets.QLineEdit(self.tab)
        self.urledit.setObjectName("urledit")
        self.horizontalLayout_2.addWidget(self.urledit)
        self.loadbtn = QtWidgets.QPushButton(self.tab)
        self.loadbtn.setObjectName("loadbtn")
        self.horizontalLayout_2.addWidget(self.loadbtn)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.verticalLayout_5.addLayout(self.verticalLayout)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setSpacing(10)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.selectallbtn = QtWidgets.QPushButton(self.tab)
        self.selectallbtn.setObjectName("pushButton_2")
        self.horizontalLayout_6.addWidget(self.selectallbtn)
        self.unselectallbtn = QtWidgets.QPushButton(self.tab)
        self.unselectallbtn.setObjectName("pushButton")
        self.horizontalLayout_6.addWidget(self.unselectallbtn)
        spacerItem1 = QtWidgets.QSpacerItem(100, 20, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem1)
        self.sitecheckbox = QtWidgets.QCheckBox(self.tab)
        self.sitecheckbox.setObjectName("checkBox_2")
        self.horizontalLayout_6.addWidget(self.sitecheckbox)
        self.pdfcheckbox = QtWidgets.QCheckBox(self.tab)
        self.pdfcheckbox.setObjectName("checkBox")
        self.horizontalLayout_6.addWidget(self.pdfcheckbox)
        self.horizontalLayout_6.setStretch(0, 10)
        self.horizontalLayout_6.setStretch(1, 10)
        self.horizontalLayout_6.setStretch(2, 40)
        self.horizontalLayout_6.setStretch(3, 5)
        self.horizontalLayout_6.setStretch(4, 5)
        self.verticalLayout_3.addLayout(self.horizontalLayout_6)
        self.chapterslist = QtWidgets.QListWidget(self.tab)
        self.chapterslist.setObjectName("chapterslist")
        self.verticalLayout_3.addWidget(self.chapterslist)
        self.downloadbtn = QtWidgets.QPushButton(self.tab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(100)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.downloadbtn.sizePolicy().hasHeightForWidth())
        self.downloadbtn.setSizePolicy(sizePolicy)
        self.downloadbtn.setMinimumSize(QtCore.QSize(0, 50))
        self.downloadbtn.setObjectName("downloadbtn")
        self.verticalLayout_3.addWidget(self.downloadbtn)
        self.verticalLayout_5.addLayout(self.verticalLayout_3)
        self.horizontalLayout_4.addLayout(self.verticalLayout_5)
        self.horizontalLayout_4.setStretch(0, 2)
        self.horizontalLayout_4.setStretch(2, 10)
        self.horizontalLayout_7.addLayout(self.horizontalLayout_4)
        self.tabWidget.addTab(self.tab, "")
        self.tab_2 = QtWidgets.QWidget()
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tab_2.sizePolicy().hasHeightForWidth())
        self.tab_2.setSizePolicy(sizePolicy)
        self.tab_2.setObjectName("tab_2")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout(self.tab_2)
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.label_3 = QtWidgets.QLabel(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(100)
        sizePolicy.setHeightForWidth(self.label_3.sizePolicy().hasHeightForWidth())
        self.label_3.setSizePolicy(sizePolicy)
        self.label_3.setMinimumSize(QtCore.QSize(0, 10))
        self.label_3.setScaledContents(False)
        self.label_3.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_8.addWidget(self.label_3)
        self.scrollArea = QtWidgets.QScrollArea(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(100)
        sizePolicy.setVerticalStretch(100)
        sizePolicy.setHeightForWidth(self.scrollArea.sizePolicy().hasHeightForWidth())
        self.scrollArea.setSizePolicy(sizePolicy)
        self.scrollArea.setMinimumSize(QtCore.QSize(100, 300))
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 914, 298))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.scrollAreaWidgetContents.sizePolicy().hasHeightForWidth())
        self.scrollAreaWidgetContents.setSizePolicy(sizePolicy)
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setSizeConstraint(QtWidgets.QLayout.SetDefaultConstraint)
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        # self.label = QtWidgets.QLabel(self.scrollAreaWidgetContents)
        # self.label.setObjectName("label")
        # self.horizontalLayout_10.addWidget(self.label)
        # self.progressBar_2 = QtWidgets.QProgressBar(self.scrollAreaWidgetContents)
        # self.progressBar_2.setProperty("value", 0)
        # self.progressBar_2.setObjectName("progressBar_2")
        # self.horizontalLayout_10.addWidget(self.progressBar_2)
        # self.verticalLayout_6.addLayout(self.horizontalLayout_10)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.horizontalLayout_8.addWidget(self.scrollArea)
        self.tabWidget.addTab(self.tab_2, "")
        self.horizontalLayout_5.addWidget(self.tabWidget)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1024, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        self.pathbtn.clicked.connect(self.changeFolder)
        self.search.textEdited.connect(self.showCurrentText)
        # self.pathedit.setText(os.path.join(os.getcwd(), "manga"))
        self.mangalist.doubleClicked.connect(self.clickmangaAsync)
        self.loadbtn.clicked.connect(self.loadchapters)
        self.downloadbtn.clicked.connect(self.download)
        self.chapterslist.currentItemChanged.connect(self.check)
        self.selectallbtn.clicked.connect(self.checkAll)
        self.unselectallbtn.clicked.connect(self.uncheckAll)
        self.mangalist.addItem("loading ... ")

        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    def addDownload(self) -> QtWidgets.QProgressBar:
        horizontalLayout_10 = QtWidgets.QHBoxLayout()
        horizontalLayout_10.setSizeConstraint(QtWidgets.QLayout.SetDefaultConstraint)
        horizontalLayout_10.setObjectName("hroz"+str(self.lastprog))
        label = QtWidgets.QLabel(self.scrollAreaWidgetContents)
        label.setObjectName("label"+str(self.lastprog))
        manga = self.mangatodownload
        label.setText(manga)
        label.setMaximumSize(200,20000)
        horizontalLayout_10.addWidget(label)
        progressBar_2 = QtWidgets.QProgressBar(self.scrollAreaWidgetContents)
        progressBar_2.setProperty("value", 0)
        progressBar_2.setObjectName("prog"+str(self.lastprog))
        # progressBar_2.setObjectName()
        # progressBar_2.objectName()




        self.progress_bars.append(progressBar_2)

        horizontalLayout_10.addWidget(progressBar_2)
        self.verticalLayout_6.addLayout(horizontalLayout_10)

        self.lastprog += 1
        return progressBar_2,label
    def check(self):
        try:
            if self.chapterslist.currentItem().checkState():
                self.chapterslist.currentItem().setCheckState(0)
            else:
                self.chapterslist.currentItem().setCheckState(2)
        except Exception as e:
            print(e)

        # self.chapterslist.currentItem().setCheckState(True)
        # print(self.chapterslist.currentItem().text())
    def updateprog(self,prog,num):
        prog.setValue(num)
    def oh_no(self):
        # Pass the function to execute
        print("oh_no entered")
        prog,label = self.addDownload()
        # prog.setValue(0)
        worker = Worker(self.execute_this_fn,**{"urlQ":self.urledit.text(),
                                                "chapterslistQ":self.chapterstodownload,
                                                "pathQ":self.pathedit.text(),
                                                 "site":self.sitecheckbox.checkState(),
                                                "pdf":self.pdfcheckbox.checkState()}) # Any other args, kwargs are passed to the run function
        worker.signals.result.connect(lambda : print("manga downloaded"))
        worker.signals.finished.connect(lambda : print("download fininshed"))
        worker.signals.progress.connect(prog.setValue)
        self.threadpool.start(worker)
        # worker.signals.progress.connect(l.setValue)

    def execute_this_fn(self, **kwargs):
        # gg.test(progress_callback)
        gg.download(**kwargs)
        # progress_callback.emit(n*100/4)

        return "Done."
    def checkAll(self):
        for i in range(self.chapterslist.count()):
            self.chapterslist.item(i).setCheckState(2)

    def uncheckAll(self):
        for i in range(self.chapterslist.count()):
            self.chapterslist.item(i).setCheckState(0)

    def showCurrentText(self):
        print(self.search.text())
        # a= self.mangalist.currentItem().text()
        print(len(self.titles))
        self.mangalist.clear()
        newarr = []
        # print(len(self.titles))
        for title in self.titles:
            if title.lower().find(self.search.text().lower()) > -1:
                newarr.append(title)
        self.mangalist.addItems(newarr)
        # print (a) # "Devilchi"

    def changeFolder(self):
        file = str(QFileDialog.getExistingDirectory(self.urledit, "Select Directory"))
        self.pathedit.setText(file)

    def loadchapters(self,link_=False):
        self.downloadbtn.setEnabled(True)
        if(link_):
            url = link_
        else:
            url= self.urledit.text()
        req = requests.get(url)
        print("url: ",url)
        self.chapterslist.clear()
        soup = bs(req.text, "html.parser")
        self.mangatodownload = soup.find("h1").text
        chapters = []
        for link in soup.findAll('a'):
            if link.has_attr('href'):
                if str(link['href']).find(url.split("/")[len(url.split("/")) - 1] + "/") != -1:
                    chapters.append(link.text)
        print("finished chapters")
        # chapters = chapters[::-1]
        print(chapters)
        if(link_):
            self.urledit.setText(link_)
        for chapter in chapters:
            item = QListWidgetItem()
            item.setText(QApplication.translate("Dialog", chapter, None))
            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            item.setCheckState(QtCore.Qt.Unchecked)
            self.chapterslist.addItem(QListWidgetItem(item))

    def clickmanga(self):
        a = self.mangalist.currentItem().text().strip().lower() # a = self.mangalist.currentItem().text().strip().lower()
        oga = self.mangalist.currentItem().text().strip()
        print("begining sub")
        a = re.sub(r"à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ", "a", a);
        print(a)
        a = re.sub(r"è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ", "e", a);
        print(a)
        a = re.sub(r"ì|í|ị|ỉ|ĩ", "i", a);
        print(a)
        a = re.sub(r"ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ", "o", a);
        print(a)
        a = re.sub(r"ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ", "u", a);
        print(a)
        a = re.sub(r"ỳ|ý|ỵ|ỷ|ỹ", "y", a);
        print(a)
        a = re.sub(r"đ", "d", a);
        print(a)
        a = re.sub(r" ", "_", a);
        print(a)
        a = re.sub(r"[^0-9a-z\s]", "_", a, flags=re.IGNORECASE);
        print(a)
        a = re.sub(r"_+_", "_", a);
        print(a)
        a = re.sub(r"^\_+|\_+$", "", a);
        print(a)
        num = 0
        while (True):  # this is for wehn the manga isnt in the first page

            req = requests.get("https://manganato.com/search/story/" + a + "?page=" + str(num))
            link=''
            soup = bs(req.text, "html.parser")
            # link = soup.find("a",class_="a-h text-nowrap item-title")['href']
            try:
                # link = str(soup.find("a", string=oga)['href'])
                def ser(string):
                    return  string == oga
                    # return str(string).find(oga) > -1
                link = str(soup.find("a", string= ser )['href'])
                # self.urledit.setText(link)
                print("link : ",link)
                print("oga("+oga+")")

                break
            except Exception as e:
                print("oga : ", oga)
                # print("a",a)
                print("oga(" + oga + ")")
                print("trace ", e)
                print(req.url)
                num = num + 1
                if num > 99:
                    break
        self.loadchapters(str(link))

    def clickmangaAsync(self):
        t = threading.Thread(target=self.clickmanga)
        t.start()

    def download(self):
        self.chapterstodownload = []
        for index in range(self.chapterslist.count()):
            if self.chapterslist.item(index).checkState():
                print(self.chapterslist.item(index).text())
                self.chapterstodownload.append(self.chapterslist.item(index).text())

                # print(self.chapterslist.item(index).text())

        # print(self.chapterstodownload)
        print("url:", self.urledit.text(), "chapters:", self.chapterstodownload, "path:", self.pathedit.text())
        config = configparser.ConfigParser()
        config.read("./data/config.ini")
        if(self.sitecheckbox.checkState() > 0):
            config.set("settings","site","True")
        else :
            config.set("settings", "site", "False")
        if(self.pdfcheckbox.checkState() > 0):
            config.set("settings","pdf","True")
        else :
            config.set("settings", "pdf", "False")
        config.set("settings","path",self.pathedit.text())
        with open('./data/config.INI', 'w') as configfile:  # save
            config.write(configfile)

        # gg.download(self.urledit.text(),self.chapterstodownload,self.pathedit.text())
        # if not self.urledit.text() or not
        if not self.chapterstodownload:
            QMessageBox.about(self.urledit, "error", "select at least 1 chapter to download")
            return
        self.oh_no()
        self.downloadbtn.setEnabled(False)


    def runTasks(self):

        # self.label.setText(f"Running {self.threadCount} Threads")
        # self.addDownload()
        self.pool = QThreadPool.globalInstance()
        # for i in range(threadCount):
            # 2. Instantiate the subclass of QRunnable
        # prog = self.addDownload()
        # runnable = Runnable(0,
        #                     self.urledit.text(),
        #                     self.chapterstodownload,
        #                     self.pathedit.text(),
        #                     # self.progress_bars[len(self.progress_bars)-1].setValue,
        #                     # lambda x: prog.setValue(x), #try with no lambda
        #                     # prog.setValue,
        #                     # lambda x: print(prog.objectName()),
        #                     # lambda x: print(x),
        #                     self.addDownload,
        #                     # lambda x : self.updateprog(prog,x),
        #                     # lambda x: prog.setValue(x) ,
        #                     self.sitecheckbox.checkState(),
        #                     self.pdfcheckbox.checkState())
        # self.pool.start(runnable)
        # runnable = Runnable(0)
        #     # 3. Call start()
        # pool.start(runnable)

    def execute(self):
        # self.update_progress(0)
        self.thread = QThread()
        self.worker = Worker()
        self.worker.site = self.sitecheckbox.checkState()
        self.worker.pdf = self.pdfcheckbox.checkState()
        self.worker.url = self.urledit.text()
        self.worker.path = self.pathedit.text()
        self.worker.chapters = self.chapterstodownload
        self.worker.moveToThread(self.thread)

        self.addDownload()
        self.worker.m = self.progress_bars[len(self.progress_bars) - 1]
        self.worker.chaptersnum = len(self.chapterstodownload)

        # self.thread.started.connect(lambda : self.worker.run(self.sitecheckbox.checkState() == 2,self.pdfcheckbox.checkState()))
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)
        self.worker.progress.connect(self.report_progress)
        # self.urledit.dropEvent(self.drag)
        self.thread.start()
        # self.threads.append(thread)
        # self.threads[len(self.threads)-1].start()

        # self.downloadbtn.setEnabled(False)
        # self.thread.finished.connect(lambda: self.downloadbtn.setEnabled(True))
    def drag(self,e=0):
        print("*"*50)
    def report_progress(self, n):
        print(n, " n")


        # m.setValue(math.ceil((n / len(self.chapterstodownload)) * 100))
        # self.progressBar.setProperty("value", n)
    def set_titles(self,it):
        self.titles = it
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MangaDownloader"))
        self.search.setPlaceholderText(_translate("MainWindow", "search"))
        MainWindow.setWindowIcon(QtGui.QIcon(os.path.join(os.getcwd(),"data","icon2222.ico")))
        __sortingEnabled = self.mangalist.isSortingEnabled()
        self.mangalist.setSortingEnabled(True)  # to sort
        self.mangalist.setSortingEnabled(__sortingEnabled)
        self.pathedit.setPlaceholderText(_translate("MainWindow", "path"))
        self.pathbtn.setText(_translate("MainWindow", "..."))
        self.urledit.setPlaceholderText(_translate("MainWindow", "url"))
        self.loadbtn.setText(_translate("MainWindow", "load chapters"))
        self.selectallbtn.setText(_translate("MainWindow", "Select All"))
        self.unselectallbtn.setText(_translate("MainWindow", "unSelect All"))
        self.sitecheckbox.setText(_translate("MainWindow", "site"))
        self.pdfcheckbox.setText(_translate("MainWindow", "pdf"))
        self.downloadbtn.setText(_translate("MainWindow", "Download"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "main"))
        self.label_3.setText(_translate("MainWindow", "downloads : "))
        # self.label.setText(_translate("MainWindow", "TextLabel"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("MainWindow", "downloads"))

        # ui.set_titles(sorted(file.read().split('\n')))

        # ui.titles = file.read().split('\n')
        # ui.mangalist.addItems(ui.titles)
        # print(len(ui.titles),list.count()," ",ui.mangalist.count())

def loadmangalist():

    with open("./data/titles.txt", "r", encoding="utf-8") as file:

        ui.mangalist.clear()

        ui.set_titles(sorted(file.read().split('\n')))
        # ui.set_titles(file.read().split('\n'))


        ui.mangalist.addItems(ui.titles)



    with open("./data/titles.txt", "a+", encoding="utf-8") as file:
        try:
            r = requests.get("https://links-update.herokuapp.com/?py=t")
        except Exception as e:
            print(e)
            print("list not updated")
            return

        titles = json.loads(r.text)
        for index, title in enumerate(titles):
            titles[index] = title["title"]
        file.truncate(0)
        file.write('\n'.join(titles))
    print("titles list updated")


def loaddefaults():
    config = configparser.ConfigParser()
    config.read("./data/config.ini")
    if(config.getboolean("settings","site")):
        ui.sitecheckbox.setCheckState(2)
    else:
        ui.sitecheckbox.setCheckState(0)
    if(config.getboolean("settings","pdf")):
        ui.pdfcheckbox.setCheckState(2)
    else:
        ui.pdfcheckbox.setCheckState(0)
    if (config.get("settings","path")):
        ui.pathedit.setText(config.get("settings","path"))
    else:
        config.set("settings","path",os.path.join(os.getcwd(),"manga"))
        ui.pathedit.setText(config.get("settings", "path"))

if __name__ == "__main__":
    import sys

    # Back up the reference to the exceptionhook
    sys._excepthook = sys.excepthook


    def my_exception_hook(exctype, value, traceback):
        # Print the error and traceback
        print(exctype, value, traceback)
        # Call the normal Exception hook after
        sys._excepthook(exctype, value, traceback)
        sys.exit(1)


    # Set the exception hook to our wrapping function
    sys.excepthook = my_exception_hook

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    loaddefaults()


    ui.downloadbtn.setEnabled(False)
    MainWindow.show()
    t = threading.Thread(target=loadmangalist)
    t.start()

    try:
        sys.exit(app.exec_())
    except:
        print("Exiting")
